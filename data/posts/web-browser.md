---
emoji: 🛰️
title: 브라우저 동작 원리
date: "2022-01-11"
category: Web
preview: "사용자가 원하는 자원을 서버에 요청하고 화면에 표시한다. 자원의 주소는 URI(Uniform Resource Indentifier)에 의해 정해진다. 자원에는 HTML, PDF, 이미지 등 다양한 형태가 있다. 사용자 인터페이스: 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분, 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작 제어, 렌더링 엔진: 서버에 요청해서 가져온 컨텐츠 표시 (HTML을 요청하면 HTML과 CSS를 파싱하여 표시), 통신: HTTP 요청과 같은 네트워크 호출에 사용된다. UI 백엔드: 콤보박스와 같은 기본적인 UI를 그린다. JS 엔진 (자바스크립트 해석기): 자바스크립트 코드를 해석하고 실행한다. 자료 저장소: 자료를 하드 디스크에 저장한다. (쿠키, 로컬 스토리지 등)"
---

# 브라우저의 주요 기능

- **사용자가 원하는 자원을 서버에 요청하고 화면에 표시한다.**
- 자원의 주소는 `URI(Uniform Resource Indentifier)`에 의해 정해진다.
- 자원에는 HTML, PDF, 이미지 등 다양한 형태가 있다.

<br/>

# 브라우저의 호환성

- **웹 표준**: 웹에서 표준적으로 사용되는 기술이나 규칙
- 웹 상에서 사용되는 모든 파일은 이러한 '웹 표준'을 가지게 되어 브라우저 내에서 어떠한 데이터 및 파일과도 상호작용이 가능하다.
- 이러한 웹 표준은 `W3C(World Wide Web Consortium)`라는 기구에 의해 명세되었고, 이들은 **웹 상호운용성**('어떠한 소프트웨어나 하드웨어에서도 웹에 접근할 수 있어야 한다')를 위해 노력 중이다.

<br/>

# 브라우저의 기본 구조

![브라우저의 기본 구조](1.png)

- **사용자 인터페이스**: 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분
  - URI를 입력할 수 있는 주소 표시줄
  - 이전 버튼과 다음 버튼
  - 북마크
  - 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼
  - 홈 버튼
- **브라우저 엔진**: 사용자 인터페이스와 렌더링 엔진 사이의 동작 제어
- **렌더링 엔진**: 서버에 요청해서 가져온 컨텐츠 표시 (HTML을 요청하면 HTML과 CSS를 파싱하여 표시)
- **통신**: HTTP 요청과 같은 네트워크 호출에 사용된다.
- **UI 백엔드**: 콤보박스와 같은 기본적인 UI를 그린다.
  - 예를 들어, `<button>`이나 `<input>` 태그를 그랠 때, 이 태그에 관한 스타일을 따로 적용하지 않아도 브라우저는 이에 맞는 UI 화면을 그리게 된다.
- **JS 엔진 (자바스크립트 해석기)**: 자바스크립트 코드를 해석하고 실행한다.
- **자료 저장소**: 자료를 하드 디스크에 저장한다. (쿠키, 로컬 스토리지 등)

> 크롬은 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 각 탭은 독립된 프로세스로 처리된다.

<br/>

# 렌더링 엔진

- 렌더링 엔진은 요청 받은 내용을 브라우저 화면에 표시한다.
- 파이어폭스는 모질라에서 직접 만든 게코(Gecko) 엔진을 사용하고 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다.

> 👉 브라우저마다 사용하는 렌더링 엔진이 다르기 때문에, 모든 브라우저가 동일한 소스를 화면에 동일하게 그려주지 않고 엔진마다 읽을 수 있는 코드의 버전도 다르기 때문에 크로스 브라우징 이슈가 발생하기도 한다.

<br/>

## 동작 과정

![브라우저 동작 과정](2.png)

1. HTML 문서를 파싱하여 **DOM 트리**를 구축한다.
2. 외부 CSS 파일과 함께 임베디드 스타일, 인라인 스타일, 브라우저 상에서 기본적으로 가지고 있는 스타일 요소들을 파싱하여 **CSSOM 트리**를 생성한다.
3. DOM 트리와 CSSOM 트리를 결합하여 `**렌더 트리**를 생성한다.
4. 렌더 트리의 각 노드의 화면(뷰포트 기준)에서의 정확한 위치와 크기를 결정한다.
5. 렌더 트리의 각 노드의 정해진 스타일, 위치, 크기에 따라 화면의 픽셀 값으로 UI를 그린다.

- 일련의 과정들이 **점진적으로 진행**된다.
- 좀 더 나은 사용자 경험을 위해 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다.
- 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.

<br/>

- 웹킷의 동작 과정
  ![](3.png)
- 게코의 동작 과정
  ![](4.png)

<br/>

### DOM 트리와 CSSOM 트리 생성

- 브라우저는 렌더링 할 문서를 HTML과 CSS로 나눠서 파싱한다.
- 브라우저는 읽어들인 HTML 바이트 데이터를 해당 파일에 지정된 인코딩 방식(meta 태그의 charset 속성)에 따라 문자열로 바꾸고, HTML 표준에 따라 문자열을 토큰으로 변환한다.
- 토큰들을 다시 노드로 바꾼다. (문서 노드, 요소 노드, 텍스트 노드 등등)
- 노드 간의 계층 관계를 바탕으로 DOM 트리가 생성된다.
  ![](5.png)
- CSS 또한 HTML과 마찬가지로, 바이트를 문자로 변환 -> 토큰화 -> 노드로 변환 -> CSSOM 트리 구축 과정을 거치게 된다.
  ![](6.png)

<br/>

### 렌더 트리 (DOM + CSSOM) 생성

- DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 생성한다.
- 이때, 렌더 트리에는 페이지를 렌더링하는데 필요한 노드(**화면에 표시되는 유효한 노드**)만 포함된다.
- 렌터 트리는 페이지에 표시되는 모든 DOM 컨텐츠와 각 노드에 대한 모든 스타일 정보를 갖고 있다.

> **렌더 트리 생성 과정**
>
> - DOM 트리의 루트에서 시작하여 노드들을 순회한다.
> - 렌더링이 되지 않는 `<script>`, `<meta>` 태그와 같은 일부 노드들은 렌더링 트리에서 제와된다.
> - 일부 노드는 CSS를 통해 숨겨지며, 렌더링 트리에서도 제외된다. 예를 들면 `display:none` 속성을 갖는 노드는 렌더링 트리에서 제외된다.
> - 화면에 표시되는 각 노드에 대해 매칭되는 CSSOM 규칙을 찾고, 적용한다.
> - 화면에 표시되는 노드를 컨텐츠 및 스타일과 함께 렌더 트리의 노드로 포함시킨다.
>   ![](7.png)

<br/>

### 렌더 트리 배치 - 레이아웃

- 뷰포트를 기준으로 렌더 트리 노드들의 위치와 크기를 계산한다.
- 모든 상대적인 측정값 (`%`, `rem`, `vh`)은 화면에서의 절대적인 픽셀값(`px`)으로 변환된다.

<br/>

### 렌더 트리 그리기 - 페인트

- UI 백엔드가 동작하여 계산된 위치와 크기를 바탕으로 렌더 트리의 각 노드를 화면에 그린다.

<br/>

### Reflow와 Repaint

- 렌더링 과정을 마친 후 특정 액션이나 이벤트에 따라 노드의 크기나 위치 등의 레이아웃 수치가 변하면 이에 영향을 받는 자식 노드나 부모 노드들을 포함하여 Layout과 Paint 과정이 다시 수행된다.
- 각 노드들의 크기와 위치를 다시 계산하는 과정을 Reflow, Reflow 이후 렌더 트리를 다시 화면에 그리는 과정을 Repaint라고 한다.
- 이때 브라우저는 화면의 변경사항이 생길 때는 최소한의 동작으로 반응하려고 노력한다.
- 즉, 노드의 위치와 크기가 변하지 않고 그 외의 스타일 요소들이 변할 경우에는 Repaint 과정만 수행한다. (opacity, background-color, outline 등등)
  - Reflow 과정이 필요하지 않다면 생략한다.
- 하지만, 노드의 위치와 크기 등의 레이아웃 수치가 변할 경우에는 Reflow와 Repaint 과정을 모두 수행한다.

<br/>

### 자바스크립트는?

- 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다.
- 렌더링 엔진이 HTML 문서를 순차적으로 파싱하다가 `script` 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진에게 제어 권한을 넘긴다.
- 제어 권한을 넘겨 받은 자바스크립트 엔진은 `script` 태그 내의 자바스크립트 코드 또는 `script` 태그의 src 속성에 지정된 자바스크립트 파일을 로드하고 파싱한다.
- 자바스크립트의 파싱이 완료되면 다시 렌더링 엔진에게 제어 권한을 넘기고 중지했던 시점부터 DOM 생성을 재개한다.
- 예외 : `script` 태그가 `defer` 속성을 가질 경우 `script` 태그를 만나도 HTML 파싱은 계속되고 완료된 후에 자바스크립트 코드가 파싱된다.

> 브라우저는 **동기(Synchronous)적으로 HTML, CSS, Javascript을 파싱**한다.
>
> - 자바스크립트는 파서 차단 리소스이다. (`parser blocking resource`)
> - 앞서 살펴봤듯이 HTML 파서가 `script` 태그를 만나면 진행하던 파싱을 중단하고 자바스크립트 엔진에게 제어 권한을 넘겨 자바스크립트 코드를 파싱하고 실행한다.
> - 따라서 script 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다.
> - 그래서 보통 `script` 태그를 `head` 태그가 아닌 `body` 태그가 닫히기 바로 전에 위치시키거나 `defer` 속성을 이용한다.

<br/>

참고

- [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)
- [브라우저 동작 과정](https://velog.io/@yejineee/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95)
- [웹 브라우저는 어떻게 작동하는가?](https://bbangson.tistory.com/87)
